<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kobra S1 Bed Mesh Visualizer</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #ffffff;
            font-size: 2em;
        }

        .upload-section {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px dashed #4a4a4a;
            transition: border-color 0.3s;
        }

        .upload-section:hover {
            border-color: #6a6a6a;
        }

        .instructions {
            text-align: left;
            margin-bottom: 25px;
            padding: 20px;
            background: #3a3a3a;
            border-radius: 8px;
        }

        .instructions h3 {
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .instructions ol {
            margin-left: 20px;
            line-height: 1.8;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .gcode-link {
            color: #4da6ff;
            text-decoration: none;
            font-weight: bold;
            padding: 2px 6px;
            background: rgba(77, 166, 255, 0.1);
            border-radius: 3px;
            transition: background 0.3s;
        }

        .gcode-link:hover {
            background: rgba(77, 166, 255, 0.2);
            text-decoration: underline;
        }

        .file-input-wrapper {
            position: relative;
            display: flex;
            width: 100%;
            justify-content: center;
        }

        input[type="file"] {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 30px;
            background: #0066cc;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }

        .file-input-label:hover {
            background: #0052a3;
        }

        .file-name {
            margin-top: 15px;
            color: #aaa;
            font-size: 14px;
            text-align: center;
        }

        .info-section {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }

        .info-section.active {
            display: block;
        }

        .profile-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .profile-btn {
            padding: 10px 20px;
            background: #3a3a3a;
            border: 2px solid #4a4a4a;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .profile-btn:hover {
            border-color: #6a6a6a;
        }

        .profile-btn.active {
            background: #0066cc;
            border-color: #0066cc;
            color: white;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(100%, 180px), 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #3a3a3a;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #0066cc;
            min-width: 0;
            overflow: hidden;
        }

        .stat-label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            word-break: break-word;
        }
		
        #plotParent {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            display: none;
        }
		
		#plotParent:has(#plotContainer.active) {
			display: block;
		}

        #plotContainer {
            min-height: 600px;
            visibility: hidden;
            height: 0;
            overflow: hidden;
        }

        #plotContainer.active {
            visibility: visible;
            height: auto;
        }

        .error {
            background: #4a2a2a;
            border: 1px solid #8a3a3a;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #ffaaaa;
        }

        .loaded-file {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: #3a3a3a;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 14px;
            cursor: grab;
            transition: background 0.2s;
        }

        .loaded-file:active {
            cursor: grabbing;
        }

        .loaded-file.dragging {
            opacity: 0.5;
        }

        .loaded-file.drag-over {
            background: #4a4a4a;
            border-top: 2px solid #0066cc;
        }

        .file-color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name-text {
            color: #e0e0e0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-remove-btn {
            padding: 4px 12px;
            background: #8a3a3a;
            border: none;
            border-radius: 4px;
            color: #ffaaaa;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }

        .file-remove-btn:hover {
            background: #aa4a4a;
        }

        .credits {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 12px;
            font-size: 14px;
            color: #aaa;
        }

        .credits a {
            color: #4da6ff;
            text-decoration: none;
            font-weight: bold;
        }

        .credits a:hover {
            text-decoration: underline;
        }

        .preset-section {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .preset-section h3 {
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .preset-btn {
            padding: 10px 20px;
            background: #3a3a3a;
            border: 2px solid #4a4a4a;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .preset-btn:hover {
            background: #0066cc;
            border-color: #0066cc;
            color: white;
        }

        .preset-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5em;
            }

            .upload-section {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Kobra S1 Bed Mesh Visualizer</h1>

        <div class="upload-section">
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" accept=".json" multiple>
                <label for="fileInput" class="file-input-label">Choose bed mesh JSON file(s)</label>
            </div>
            <div class="file-name" id="fileName"></div>
            <div id="loadedFiles" style="margin-top: 15px;"></div>
        </div>

        <div class="preset-section">
            <h3>Load Preset Files</h3>
            <div class="preset-buttons">
                <button class="preset-btn" onclick="loadPresetFile('stock.json')">Stock</button>
                <button class="preset-btn" onclick="loadPresetFile('stock_2.json')">Stock 2</button>
                <button class="preset-btn" onclick="loadPresetFile('stock_3.json')">Stock 3</button>
                <button class="preset-btn" onclick="loadPresetFile('funssor_bed.json')">Funssor Bed</button>
            </div>
        </div>

        <div id="errorContainer"></div>

        <div class="info-section" id="infoSection">
            <div class="profile-selector" id="profileSelector"></div>
            <div class="stats" id="statsContainer"></div>
        </div>
		<div id="plotParent">
			<div id="plotContainer"></div>
		</div>

        <div class="credits">
            Based on <a href="https://github.com/suchmememanyskill/bens-claude-cc-mesh-visualiser" target="_blank" rel="noopener noreferrer">Ben's Bed Mesh Visualizer</a>
        </div>
    </div>

    <script>
        let loadedFiles = [];
        const colorPalette = [
            '#0066cc', '#cc0066', '#66cc00', '#cc6600',
            '#6600cc', '#00cc66', '#cc0000', '#0066ff',
            '#ff6600', '#00cccc', '#cc00cc', '#cccc00'
        ];

        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="error">${message}</div>`;
        }

        function clearError() {
            document.getElementById('errorContainer').innerHTML = '';
        }

        function parseJsonProfile(profileData) {
            // Validate that this looks like a bed mesh profile
            if (!profileData || typeof profileData !== 'object') {
                return null;
            }

            // Check for required fields
            if (!profileData.points || !profileData.x_count || !profileData.y_count ||
                !profileData.min_x || !profileData.max_x ||
                !profileData.min_y || !profileData.max_y) {
                return null;
            }

            // Parse points from newline-separated string
            const pointsStr = profileData.points;
            const rows = pointsStr.trim().split('\n');
            const points = rows.map(row =>
                row.split(',').map(p => parseFloat(p.trim()))
            );

            const meshConfigs = {
                min_x: parseFloat(profileData.min_x),
                max_x: parseFloat(profileData.max_x),
                min_y: parseFloat(profileData.min_y),
                max_y: parseFloat(profileData.max_y),
                x_count: parseInt(profileData.x_count),
                y_count: parseInt(profileData.y_count)
            };

            // Validate point count
            const expectedPoints = meshConfigs.x_count * meshConfigs.y_count;
            const actualPoints = points.reduce((sum, row) => sum + row.length, 0);
            if (actualPoints !== expectedPoints) {
                console.warn(`Expected ${expectedPoints} values, found ${actualPoints}`);
                return null;
            }

            return {
                points: points,
                configs: meshConfigs
            };
        }

        function createOverlayPlot(visibleProfiles) {
            const data = [];
            let globalMinZ = Infinity;
            let globalMaxZ = -Infinity;
            let globalMinX = Infinity;
            let globalMaxX = -Infinity;
            let globalMinY = Infinity;
            let globalMaxY = -Infinity;

            // First pass: calculate global bounds and prepare mesh data
            const meshData = [];
            visibleProfiles.forEach((profile, index) => {
                const points = profile.mesh.points;
                const configs = profile.mesh.configs;

                // Create coordinate arrays
                const xCoords = [];
                const yCoords = [];
                for (let i = 0; i < configs.x_count; i++) {
                    xCoords.push(configs.min_x + (configs.max_x - configs.min_x) * i / (configs.x_count - 1));
                }
                for (let i = 0; i < configs.y_count; i++) {
                    yCoords.push(configs.min_y + (configs.max_y - configs.min_y) * i / (configs.y_count - 1));
                }

                // Update global bounds
                const flatPoints = points.flat();
                globalMinZ = Math.min(globalMinZ, ...flatPoints);
                globalMaxZ = Math.max(globalMaxZ, ...flatPoints);
                globalMinX = Math.min(globalMinX, configs.min_x);
                globalMaxX = Math.max(globalMaxX, configs.max_x);
                globalMinY = Math.min(globalMinY, configs.min_y);
                globalMaxY = Math.max(globalMaxY, configs.max_y);

                // Store mesh data for later
                meshData.push({
                    profile: profile,
                    xCoords: xCoords,
                    yCoords: yCoords,
                    points: points
                });
            });

            // Function to create cylinder geometry
            function createCylinder(centerX, centerY, radius, height, segments = 16) {
                const x = [], y = [], z = [];
                const i = [], j = [], k = [];

                // Create top and bottom circles
                for (let s = 0; s <= segments; s++) {
                    const angle = (s / segments) * 2 * Math.PI;
                    const dx = radius * Math.cos(angle);
                    const dy = radius * Math.sin(angle);

                    // Bottom circle
                    x.push(centerX + dx);
                    y.push(centerY + dy);
                    z.push(0);

                    // Top circle
                    x.push(centerX + dx);
                    y.push(centerY + dy);
                    z.push(height);
                }

                // Create faces for cylinder sides
                for (let s = 0; s < segments; s++) {
                    const b1 = s * 2;
                    const t1 = s * 2 + 1;
                    const b2 = ((s + 1) % (segments + 1)) * 2;
                    const t2 = ((s + 1) % (segments + 1)) * 2 + 1;

                    // Two triangles per segment
                    i.push(b1); j.push(t1); k.push(b2);
                    i.push(b2); j.push(t1); k.push(t2);
                }

                // Add center points for top and bottom caps
                const bottomCenter = x.length;
                x.push(centerX); y.push(centerY); z.push(0);
                const topCenter = x.length;
                x.push(centerX); y.push(centerY); z.push(height);

                // Create faces for bottom cap
                for (let s = 0; s < segments; s++) {
                    const b1 = s * 2;
                    const b2 = ((s + 1) % (segments + 1)) * 2;
                    i.push(bottomCenter); j.push(b1); k.push(b2);
                }

                // Create faces for top cap
                for (let s = 0; s < segments; s++) {
                    const t1 = s * 2 + 1;
                    const t2 = ((s + 1) % (segments + 1)) * 2 + 1;
                    i.push(topCenter); j.push(t2); k.push(t1);
                }

                return { x, y, z, i, j, k };
            }

            // Add leadscrew position markers as cylinders FIRST (render behind)
            const leadscrewPositions = [
                { x: -20, y: -10, name: 'Front Left' },
                { x: 276, y: -10, name: 'Front Right' },
                { x: 128, y: 276, name: 'Back Middle' }
            ];

            leadscrewPositions.forEach(pos => {
                // Create small cylinder markers with fixed height
                const cylinderHeight = Math.max(0.5, (globalMaxZ - globalMinZ) * 0.3);
                const cylinderBase = globalMinZ - cylinderHeight * 0.2;

                // Generate cylinder geometry manually with adjusted z coordinates
                const cylinder = createCylinder(pos.x, pos.y, 5, cylinderHeight, 16);
                const adjustedZ = cylinder.z.map(z => z + cylinderBase);

                data.push({
                    type: 'mesh3d',
                    x: cylinder.x,
                    y: cylinder.y,
                    z: adjustedZ,
                    i: cylinder.i,
                    j: cylinder.j,
                    k: cylinder.k,
                    color: '#ff0000',
                    opacity: 0.7,
                    name: pos.name,
                    hovertemplate: `${pos.name}<br>X: ${pos.x} mm<br>Y: ${pos.y} mm<extra></extra>`,
                    lighting: {
                        ambient: 0.6,
                        diffuse: 0.8,
                        specular: 0.2,
                        roughness: 0.5
                    }
                });
            });

            // Now add mesh surfaces (will render on top)
            meshData.forEach(mesh => {
                const color = mesh.profile.color;
                const colorWithAlpha = color + 'cc'; // Add transparency

                data.push({
                    type: 'surface',
                    x: mesh.xCoords,
                    y: mesh.yCoords,
                    z: mesh.points,
                    colorscale: [[0, colorWithAlpha], [1, colorWithAlpha]],
                    showscale: false,
                    name: mesh.profile.name,
                    hovertemplate: `${mesh.profile.name}<br>X: %{x:.1f} mm<br>Y: %{y:.1f} mm<br>Z: %{z:.3f} mm<extra></extra>`
                });
            });

            // Add z=0 reference plane
            const zeroPlane = Array(2).fill(null).map(() => Array(2).fill(0));
            const planeX = [globalMinX, globalMaxX];
            const planeY = [globalMinY, globalMaxY];

            data.push({
                type: 'surface',
                x: planeX,
                y: planeY,
                z: zeroPlane,
                colorscale: [[0, 'rgba(100, 255, 100, 0.2)'], [1, 'rgba(100, 255, 100, 0.2)']],
                showscale: false,
                name: 'Z=0 Reference',
                hovertemplate: 'X: %{x:.1f} mm<br>Y: %{y:.1f} mm<br>Z: 0.000 mm<extra></extra>'
            });

            // Calculate statistics for all visible meshes
            const globalFlatnessDev = globalMaxZ - globalMinZ;

            // Calculate per-mesh statistics
            const meshStats = visibleProfiles.map(profile => {
                const flatPoints = profile.mesh.points.flat();
                const minZ = Math.min(...flatPoints);
                const maxZ = Math.max(...flatPoints);
                const deviation = maxZ - minZ;
                return {
                    name: profile.name,
                    color: profile.color,
                    minZ,
                    maxZ,
                    deviation
                };
            });

            // Calculate deviation differences between meshes
            let deviationDifferences = [];
            if (meshStats.length > 1) {
                const deviations = meshStats.map(s => s.deviation);
                const maxDeviation = Math.max(...deviations);
                const minDeviation = Math.min(...deviations);
                const deviationDiff = maxDeviation - minDeviation;

                deviationDifferences = meshStats.map(s => ({
                    name: s.name,
                    color: s.color,
                    deviation: s.deviation,
                    diffFromMin: s.deviation - minDeviation,
                    diffFromMax: maxDeviation - s.deviation
                }));
            }

            // Build stats HTML
            let statsHTML = `
                <div class="stat-card" style="grid-column: 1 / -1; border-left-color: #00cc66;">
                    <div class="stat-label">Global Overview</div>
                    <div class="stat-value" style="font-size: 14px;">
                        Min: ${globalMinZ.toFixed(5)} mm | Max: ${globalMaxZ.toFixed(5)} mm | Deviation: ${globalFlatnessDev.toFixed(5)} mm
                    </div>
                </div>
            `;

            if (meshStats.length > 1) {
                const deviations = meshStats.map(s => s.deviation);
                const maxDeviation = Math.max(...deviations);
                const minDeviation = Math.min(...deviations);
                const deviationDiff = maxDeviation - minDeviation;

                statsHTML += `
                    <div class="stat-card" style="grid-column: 1 / -1; border-left-color: #cc6600;">
                        <div class="stat-label">Deviation Difference (Flatness Similarity)</div>
                        <div class="stat-value">${deviationDiff.toFixed(5)} mm</div>
                    </div>
                `;
            }

            // Add per-mesh stats
            meshStats.forEach(stat => {
                statsHTML += `
                    <div class="stat-card" style="grid-column: 1 / -1; border-left-color: ${stat.color};">
                        <div class="stat-label">${stat.name}</div>
                        <div class="stat-value" style="font-size: 14px;">
                            Min: ${stat.minZ.toFixed(5)} mm | Max: ${stat.maxZ.toFixed(5)} mm | Dev: ${stat.deviation.toFixed(5)} mm
                        </div>
                    </div>
                `;
            });

            document.getElementById('statsContainer').innerHTML = statsHTML;

            const layout = {
                title: {
                    text: `Bed Mesh Overlay<br><sub>${visibleProfiles.length} mesh${visibleProfiles.length !== 1 ? 'es' : ''} shown | Flatness deviation: ${globalFlatnessDev.toFixed(3)} mm</sub>`,
                    font: { color: '#e0e0e0' }
                },
                scene: {
                    xaxis: { title: 'X (mm)', color: '#e0e0e0', gridcolor: '#4a4a4a' },
                    yaxis: { title: 'Y (mm)', color: '#e0e0e0', gridcolor: '#4a4a4a' },
                    zaxis: { title: 'Height (mm)', color: '#e0e0e0', gridcolor: '#4a4a4a' },
                    bgcolor: '#2a2a2a',
                    camera: {
                        eye: { x: 1.5, y: 1.5, z: 1.3 }
                    }
                },
                paper_bgcolor: '#2a2a2a',
                plot_bgcolor: '#2a2a2a',
                font: { color: '#e0e0e0' },
                margin: { l: 0, r: 0, t: 80, b: 0 },
                showlegend: true,
                legend: {
                    x: 0,
                    y: 1,
                    bgcolor: 'rgba(42, 42, 42, 0.8)',
                    bordercolor: '#4a4a4a',
                    borderwidth: 1
                }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            // Check if plot already exists and preserve camera position
            const plotContainer = document.getElementById('plotContainer');
            if (plotContainer.data && plotContainer.layout && plotContainer.layout.scene) {
                // Preserve the current camera position
                layout.scene.camera = plotContainer.layout.scene.camera;
            }

            Plotly.react('plotContainer', data, layout, config);

            // Force resize to ensure proper width
            setTimeout(() => {
                Plotly.Plots.resize('plotContainer');
            }, 100);
        }

        function updateLoadedFilesList() {
            const container = document.getElementById('loadedFiles');
            if (loadedFiles.length === 0) {
                container.innerHTML = '';
                return;
            }

            // Reassign colors based on current order
            loadedFiles.forEach((file, index) => {
                file.color = colorPalette[index % colorPalette.length];
            });

            container.innerHTML = loadedFiles.map((file, index) => `
                <div class="loaded-file" draggable="true" data-index="${index}">
                    <div class="file-color-box" style="background: ${file.color};"></div>
                    <div class="file-info">
                        <div class="file-name-text">${file.fileName} (${Object.keys(file.profiles).length} profile${Object.keys(file.profiles).length !== 1 ? 's' : ''})</div>
                    </div>
                    <button class="file-remove-btn" onclick="removeFile(${index})">Remove</button>
                </div>
            `).join('');

            // Add drag and drop event listeners
            const fileElements = container.querySelectorAll('.loaded-file');
            fileElements.forEach(el => {
                el.addEventListener('dragstart', handleDragStart);
                el.addEventListener('dragend', handleDragEnd);
                el.addEventListener('dragover', handleDragOver);
                el.addEventListener('drop', handleDrop);
                el.addEventListener('dragleave', handleDragLeave);
            });
        }

        let draggedIndex = null;

        function handleDragStart(e) {
            draggedIndex = parseInt(e.currentTarget.dataset.index);
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            document.querySelectorAll('.loaded-file').forEach(el => {
                el.classList.remove('drag-over');
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const currentTarget = e.currentTarget;
            if (!currentTarget.classList.contains('dragging')) {
                currentTarget.classList.add('drag-over');
            }
            return false;
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            const dropIndex = parseInt(e.currentTarget.dataset.index);

            if (draggedIndex !== null && draggedIndex !== dropIndex) {
                // Reorder the array
                const draggedItem = loadedFiles[draggedIndex];
                loadedFiles.splice(draggedIndex, 1);
                loadedFiles.splice(dropIndex, 0, draggedItem);

                // Update UI
                updateLoadedFilesList();
                updateProfileSelector();
                updatePlot();
            }

            return false;
        }

        function removeFile(index) {
            loadedFiles.splice(index, 1);
            updateLoadedFilesList();
            updateProfileSelector();
            updatePlot();
        }

        function updateProfileSelector() {
            const profileSelector = document.getElementById('profileSelector');
            profileSelector.innerHTML = '';

            if (loadedFiles.length === 0) {
                document.getElementById('infoSection').classList.remove('active');
                document.getElementById('plotContainer').classList.remove('active');
                return;
            }

            // Create buttons for each profile from each file
            loadedFiles.forEach((file, fileIndex) => {
                Object.entries(file.profiles).forEach(([profileKey, profile]) => {
                    const btn = document.createElement('button');
                    btn.className = 'profile-btn active';
                    btn.textContent = `${file.fileName}: ${profile.name}`;
                    btn.style.borderLeft = `4px solid ${file.color}`;
                    btn.dataset.fileIndex = fileIndex;
                    btn.dataset.profileKey = profileKey;
                    btn.onclick = () => toggleProfile(fileIndex, profileKey);
                    profileSelector.appendChild(btn);
                });
            });

            document.getElementById('infoSection').classList.add('active');
        }

        function toggleProfile(fileIndex, profileKey) {
            const file = loadedFiles[fileIndex];
            const profile = file.profiles[profileKey];
            profile.visible = !profile.visible;

            // Update button state
            const btn = document.querySelector(`[data-file-index="${fileIndex}"][data-profile-key="${profileKey}"]`);
            btn.classList.toggle('active', profile.visible);

            updatePlot();
        }

        function updatePlot() {
            if (loadedFiles.length === 0) {
                document.getElementById('plotContainer').classList.remove('active');
                return;
            }

            // Collect all visible profiles
            const visibleProfiles = [];
            loadedFiles.forEach(file => {
                Object.entries(file.profiles).forEach(([key, profile]) => {
                    if (profile.visible) {
                        visibleProfiles.push({
                            name: `${file.fileName}: ${profile.name}`,
                            color: file.color,
                            mesh: profile.mesh
                        });
                    }
                });
            });

            if (visibleProfiles.length === 0) {
                document.getElementById('plotContainer').classList.remove('active');
                return;
            }

            createOverlayPlot(visibleProfiles);
            document.getElementById('plotContainer').classList.add('active');
        }

        function processFile(fileName, content) {
            clearError();

            try {
                const jsonData = JSON.parse(content);
                const profiles = {};

                // Process each profile in the JSON
                for (const [key, profileData] of Object.entries(jsonData)) {
                    const mesh = parseJsonProfile(profileData);
                    if (mesh) {
                        profiles[key] = {
                            name: key,
                            mesh: mesh,
                            visible: true
                        };
                    }
                }

                if (Object.keys(profiles).length === 0) {
                    showError(`No valid bed mesh profiles found in ${fileName}.`);
                    return;
                }

                // Add file to loaded files
                const color = colorPalette[loadedFiles.length % colorPalette.length];
                loadedFiles.push({
                    fileName: fileName,
                    color: color,
                    profiles: profiles
                });

                updateLoadedFilesList();
                updateProfileSelector();
                updatePlot();

            } catch (e) {
                showError(`Invalid JSON file "${fileName}". Error: ${e.message}`);
            }
        }

        // Load preset file from server
        async function loadPresetFile(filename) {
            clearError();

            // Disable all preset buttons during loading
            document.querySelectorAll('.preset-btn').forEach(btn => btn.disabled = true);

            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`Failed to load ${filename}: ${response.statusText}`);
                }
                const content = await response.text();
                processFile(filename, content);
            } catch (e) {
                showError(`Error loading preset file "${filename}": ${e.message}`);
            } finally {
                // Re-enable all preset buttons
                document.querySelectorAll('.preset-btn').forEach(btn => btn.disabled = false);
            }
        }

        // File upload handler
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;

            document.getElementById('fileName').textContent = `Selected: ${files.length} file${files.length !== 1 ? 's' : ''}`;

            // Process each file
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    processFile(file.name, event.target.result);
                };
                reader.onerror = function() {
                    showError(`Error reading file "${file.name}". Please try again.`);
                };
                reader.readAsText(file);
            });

            // Reset file input so the same file can be loaded again
            e.target.value = '';
        });

        // Drag and drop support
        const uploadSection = document.querySelector('.upload-section');

        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.style.borderColor = '#0066cc';
        });

        uploadSection.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadSection.style.borderColor = '#4a4a4a';
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.style.borderColor = '#4a4a4a';

            const files = e.dataTransfer.files;
            if (files && files.length > 0) {
                document.getElementById('fileName').textContent = `Selected: ${files.length} file${files.length !== 1 ? 's' : ''}`;

                // Process each file
                Array.from(files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        processFile(file.name, event.target.result);
                    };
                    reader.onerror = function() {
                        showError(`Error reading file "${file.name}". Please try again.`);
                    };
                    reader.readAsText(file);
                });
            }
        });
    </script>
</body>
</html>
